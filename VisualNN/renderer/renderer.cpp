//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 
// MIT License
// 
// Copyright(c) 2023 Gerald Filimonov
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "renderer.h"

bool Renderer::m_initialized = false;

std::vector<InstanceGroup*> Renderer::m_InstanceGroups;
std::vector<LineGroup *> Renderer::m_LineGroups;

const unsigned int Renderer::MaxVertexCount = 1000000;
const unsigned int Renderer::MaxIndexCount = 1000000;
const unsigned int Renderer::MaxInstanceCount = 1000000;

VertexArray *Renderer::m_VAO = nullptr;
VertexBuffer *Renderer::m_VBO = nullptr;
IndexBuffer *Renderer::m_IBO = nullptr;

VertexArray *Renderer::m_batchVAO = nullptr;
VertexBuffer *Renderer::m_batchVBO = nullptr;
IndexBuffer *Renderer::m_batchIBO = nullptr;

VertexArray *Renderer::m_instanceVAO = nullptr;
VertexBuffer *Renderer::m_instanceVBO = nullptr;
IndexBuffer *Renderer::m_instanceIBO = nullptr;
InstanceBuffer *Renderer::m_instanceNBO = nullptr;

VertexArray *Renderer::m_lineVAO = nullptr;
VertexBuffer *Renderer::m_lineVBO = nullptr;

glm::mat4 Renderer::m_matrixView;
glm::mat4 Renderer::m_matrixProjection;




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  CTORs/DTORs
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



Renderer::Renderer() {}

Renderer::~Renderer() {

	//create the buffers the renderer will use
	if (m_VAO) delete m_VAO;
	if (m_VBO) delete m_VBO;
	if (m_IBO) delete m_IBO;

	if (m_batchVAO) delete m_batchVAO;
	if (m_batchVBO) delete m_batchVBO;
	if (m_batchIBO) delete m_batchIBO;

	//buffers for drawing instanced geometry
	if (m_instanceVAO) delete m_instanceVAO;
	if (m_instanceVBO) delete m_instanceVBO;
	if (m_instanceIBO) delete m_instanceIBO;
	if (m_instanceIBO) delete m_instanceNBO;

	//buffers for drawing lines
	if (m_lineVAO) delete m_lineVAO;
	if (m_lineVBO) delete m_lineVBO;
	
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function init()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Renderer::init() {

	//create the buffers the renderer will use
	m_VAO = new VertexArray();
	m_VBO = new VertexBuffer(Renderer::MaxVertexCount * sizeof(Vertex));
	m_IBO = new IndexBuffer(Renderer::MaxIndexCount * sizeof(unsigned int));

	m_batchVAO = new VertexArray();
	m_batchVBO = new VertexBuffer(Renderer::MaxVertexCount * sizeof(Vertex));
	m_batchIBO = new IndexBuffer(Renderer::MaxIndexCount * sizeof(unsigned int));	

	//buffers for drawing instanced geometry
	m_instanceVAO = new VertexArray();
	m_instanceVBO = new VertexBuffer(Renderer::MaxVertexCount * sizeof(Vertex));
	m_instanceIBO = new IndexBuffer(Renderer::MaxIndexCount * sizeof(unsigned int));
	m_instanceNBO = new InstanceBuffer(Renderer::MaxInstanceCount * sizeof(glm::mat4));

	//buffers for drawing lines
	m_lineVAO = new VertexArray();
	m_lineVBO = new VertexBuffer(Renderer::MaxVertexCount * sizeof(Vertex));


	m_initialized = true;
	return true;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function clear()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::clear(glm::vec3 color) {
	glClearColor(color.x, color.y, color.z, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}



void Renderer::setWireFrame(bool flag) {
	if (flag) {
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	}
	else {
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	}
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function beginBatches()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::beginBatches() {

	m_batchVBO->reset();
	m_batchIBO->reset();
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function beginLines()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::beginLines() {
	m_lineVBO->reset();	
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function beginInstances()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::beginInstances() {
	m_instanceVBO->reset();
	m_instanceIBO->reset();
	m_instanceNBO->reset();
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function begin()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::begin(glm::mat4 matrixView, glm::mat4 matrixProjection) {

	//set the camera
	//TODO: make this a real camera class
	m_matrixView = matrixView;
	m_matrixProjection = matrixProjection;	

	//reset EVERYTHING, it's about to get juicy!!
	m_VBO->reset();
	m_IBO->reset();		


	beginBatches();
	beginLines();
	beginInstances();	

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function submitMesh()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::submitMesh(std::shared_ptr<Mesh> mesh, std::shared_ptr<Material> material, glm::mat4 modelMatrix) {

	//TODO: Need to move this back out to somewhere else
	glm::vec4 lightPosition(0.0f, 10.0f, 0.0f, 1.0f);

	glm::vec4 lightAmbientColor(0.3f, 0.3f, 0.3f, 1);
	glm::vec4 lightDiffuseColor(0.7f, 0.7f, 0.7f, 1);
	glm::vec4 lightSpecularColor(0.7f, 0.7f, 0.7f, 1);

	m_VBO->pushVertices(mesh->m_Vertices);
	m_IBO->pushIndices(mesh->m_Indices,0);

	m_VAO->bind();
	m_VBO->bind();
	m_IBO->bind();

	material->bind();	
	//set up lights
	material->setUniformFloat4("u_lightPosition", lightPosition);

	material->setUniformFloat4("u_lightAmbientColor", lightAmbientColor);
	material->setUniformFloat4("u_lightDiffuseColor", lightDiffuseColor);
	material->setUniformFloat4("u_lightSpecularColor", lightSpecularColor);

	material->setUniformMat4("u_matrixModel", modelMatrix);
	material->setUniformMat4("u_matrixView", Renderer::m_matrixView);
	material->setUniformMat4("u_matrixProjection", Renderer::m_matrixProjection);

	glDrawElements(GL_TRIANGLES, m_IBO->getIndices().size(), GL_UNSIGNED_INT, 0);
	GLError::GLCheckError();

	//were done! clear out the buffers for next time
	m_VBO->reset();
	m_IBO->reset();


}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function submitMeshBatched()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::submitMeshBatched(std::shared_ptr<Mesh> mesh, std::shared_ptr<Material> material, glm::mat4 modelMatrix) {


	//see if theres room in da buffa
	if ((m_batchVBO->getVertices().size() + mesh->m_Vertices.size() > MaxVertexCount) ||
		(m_batchIBO->getIndices().size() + mesh->m_Indices.size() > MaxIndexCount)) {
		endBatches();
		beginBatches();
	}

	//transform the vertices according to the modelMatrix	
	std::vector<Vertex> tempverts = mesh->m_Vertices;

	for (auto &vertex : tempverts) {
		vertex.m_Position = glm::vec3(modelMatrix * glm::vec4(vertex.m_Position, 1.0f));
		// If you have normals, you may need to transform them as well:
		vertex.m_Normal = glm::normalize(glm::mat3(glm::transpose(glm::inverse(modelMatrix))) * vertex.m_Normal);
	}

	int offset = m_batchVBO->pushVertices(tempverts);
	m_batchIBO->pushIndices(mesh->m_Indices, offset);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function submitMeshInstanced()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::submitMeshInstanced(std::shared_ptr<Mesh> mesh, std::shared_ptr<Material> material, glm::mat4 modelMatrix) {


	//see if mesh and material combo is in the instancegroup list	
	for (InstanceGroup *ig : m_InstanceGroups) {

		// if the mesh, material and texture matches any of the groups, add it to the appropriate group
		if (ig->m_Material->m_MaterialName == material->m_MaterialName && ig->m_Mesh->m_MeshName == mesh->m_MeshName && ig->texture->getID() == material->m_Textures[0]->getID()) {			
			//add modelMatrix to the modelmatrix buffer
			ig->addInstanceAttributes(modelMatrix, material->m_AmbientColor, material->m_DiffuseColor);			
			return;

		}
	}

	//if we get here we didnt find a matching existing group, so create a new one and continue
	InstanceGroup *newig = new InstanceGroup(material, mesh);
	newig->addInstanceAttributes(modelMatrix, material->m_AmbientColor, material->m_DiffuseColor);
	newig->texture = material->m_Textures[0];

	//add the group to the big list
	m_InstanceGroups.push_back(newig);
	

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function SubmitLine()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::SubmitLine(Vertex v0, Vertex v1, std::shared_ptr<Material> material) {

	//see if mesh and material combo is in the instancegroup list	
	for (LineGroup *lg : m_LineGroups) {
		if (lg->m_Material->m_MaterialName == material->m_MaterialName) {			
			lg->addLine(v0, v1);
			return;

		}
	}

	//if we get here we didnt find an existing one, so create a new one and continue
	LineGroup *newlg = new LineGroup(material);
	newlg->addLine(v0, v1);
	m_LineGroups.push_back(newlg);	

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function end()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::end() {

	m_VBO->reset();
	m_IBO->reset();

	// Draw batches if necessary
	endBatches();
	// Draw lines if necessary
	endLines();
	// Draw instancegroups if necessary
	endInstances();

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function endBatches()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::endBatches() {

	if (m_batchIBO->getIndices().size()) {

		m_batchVAO->bind();
		m_batchVBO->bind();
		m_batchIBO->bind();

		glDrawElements(GL_TRIANGLES, m_batchIBO->getIndices().size(), GL_UNSIGNED_INT, 0);
		GLError::GLCheckError();

		//were done! clear out the buffers for next time
		m_batchVBO->reset();
		m_batchIBO->reset();
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function endLines()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::endLines() {

	//render/flush instancegroups
	for (LineGroup *lg : m_LineGroups) {		

		lg->m_Material->bind();

		//setup camera matrices
		lg->m_Material->setUniformMat4("u_matrixView", Renderer::m_matrixView);
		lg->m_Material->setUniformMat4("u_matrixProjection", Renderer::m_matrixProjection);
		
		m_lineVBO->pushVertices(lg->m_endPoints);

		m_lineVAO->bind();
		m_lineVBO->bind();		

		glDrawArrays(GL_LINES, 0, m_lineVBO->getVertices().size());

		m_lineVBO->reset();

		delete lg;

	}

	m_LineGroups.clear();
	
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function endInstances()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Renderer::endInstances() {


	//TODO: Need to move this back out to somewhere else
	glm::vec4 lightPosition(0.0f, 10.0f, 0.0f, 1.0f);

	glm::vec4 lightAmbientColor(0.3f, 0.3f, 0.3f, 1);
	glm::vec4 lightDiffuseColor(0.7f, 0.7f, 0.7f, 1);
	glm::vec4 lightSpecularColor(0.7f, 0.7f, 0.7f, 1);

	

	//TODID: render/flush instancegroups
	for (InstanceGroup *ig : m_InstanceGroups) {
		

		ig->m_Material->bind();

		//setup camera matrices
		ig->m_Material->setUniformMat4("u_matrixView", Renderer::m_matrixView);
		ig->m_Material->setUniformMat4("u_matrixProjection", Renderer::m_matrixProjection);

		//set up lights
		ig->m_Material->setUniformFloat4("u_lightPosition", lightPosition);
		ig->m_Material->setUniformFloat4("u_lightAmbientColor", lightAmbientColor);
		ig->m_Material->setUniformFloat4("u_lightDiffuseColor", lightDiffuseColor);
		ig->m_Material->setUniformFloat4("u_lightSpecularColor", lightSpecularColor);		

		m_instanceVBO->pushVertices(ig->m_Mesh->m_Vertices);
		m_instanceIBO->pushIndices(ig->m_Mesh->m_Indices,0);
		m_instanceNBO->pushInstanceAttributesSet(ig->m_InstanceAttributes);	

		m_instanceVAO->bind();
		m_instanceVBO->bind();
		m_instanceIBO->bind();
		m_instanceNBO->bind();		
		
		glDrawElementsInstanced(GL_TRIANGLES, m_instanceIBO->getIndices().size(), GL_UNSIGNED_INT, 0, m_instanceNBO->getAttributes().size()); GLError::GLCheckError();

		m_instanceVBO->reset();
		m_instanceIBO->reset();
		m_instanceNBO->reset();

		delete ig;

	}
	m_InstanceGroups.clear();	

}





