//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// 
// MIT License
// 
// Copyright(c) 2023 Gerald Filimonov
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "shader.h"


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  CTORs/DTORs
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Shader::Shader() {
    m_program = 0;
}

Shader::Shader(std::string vertextShader, std::string fragmentShader)
{

    // Load shaders from files
    //TODO: rename this to ShaderCode or soemthing
    std::string  vShaderSource;
    std::string  fShaderSource;
    readFile(vertextShader, vShaderSource);
    readFile(fragmentShader, fShaderSource);
    Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Loaded Shader!");
    if (vShaderSource == "" || fShaderSource == "")
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Failed load shaders from files");
        return;
    }

    // Initialize the shaders
    if (!initShaders(vShaderSource, fShaderSource, m_program))
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Failed to initialize the shaders");
        return;
    }
}

Shader::~Shader() {


}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function readFile()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shader::readFile(std::string shaderFileName, std::string& shaderSource)
{
    shaderSource = "";

    //clear out existing logfile 
    if (!std::filesystem::exists(shaderFileName))
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Could not find file: " + shaderFileName);
        return;
    }

    std::ifstream inFile;
    inFile.open(shaderFileName); //open the input file

    std::stringstream strStream;
    strStream << inFile.rdbuf(); //read the file
    shaderSource = strStream.str(); //str holds the content of the file

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function InitShaders()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool Shader::initShaders(std::string vShaderSource, std::string fShaderSource, int& program)
{
    program = createProgram(vShaderSource, fShaderSource);
    if (program == 0)
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Failed to create program");
        return false;
    }

    return true;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function CreateProgram()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Shader::createProgram(std::string vShader, std::string fShader)
{
    // Create shader object
    int vertexShader = loadShader(GL_VERTEX_SHADER, vShader);
    int fragmentShader = loadShader(GL_FRAGMENT_SHADER, fShader);
    if (vertexShader == 0 || fragmentShader == 0)
    {
        return 0;
    }

    // Create a program object
    int program = glCreateProgram();
    GLError::GLCheckError();
    if (program == 0)
    {
        return 0;
    }

    // Attach the shader objects
    glAttachShader(program, vertexShader); GLError::GLCheckError();
    glAttachShader(program, fragmentShader); GLError::GLCheckError();

    // Link the program object
    glLinkProgram(program); GLError::GLCheckError();


    //did we link correctly?
    int status;
    glGetProgramiv(program, GL_LINK_STATUS, &status); GLError::GLCheckError();
    if (status == GL_FALSE)
    {
        int maxLength = 0;
        glGetShaderiv(program, GL_INFO_LOG_LENGTH, &maxLength);

        std::vector<char> errorLog(maxLength);
        glGetProgramInfoLog(program, maxLength, &maxLength, &errorLog[0]);
        

        Logger::Append(Logger::LogLevel::LOGLEVEL_ERROR, "Shader linking failed!");
        Logger::Append(Logger::LogLevel::LOGLEVEL_ERROR, &errorLog[0]);

        return 0;

    }


    return program;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function LoadShader()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Shader::loadShader(GLenum shaderType, std::string shaderSource)
{
    // Create shader object

    GLError::GLClearError();
    int shader = glCreateShader(shaderType); GLError::GLCheckError();
    if (shader == 0)
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Unable to create shader");
        return 0;
    }

    // Set the shader program

    const char* c_str = shaderSource.c_str();
    glShaderSource(shader, 1, &c_str, NULL); GLError::GLCheckError();

    // Compile the shader
    glCompileShader(shader); GLError::GLCheckError();

    // Check the result of compilation
    int status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &status); GLError::GLCheckError();    
    if (status == GL_FALSE)
    {
        int maxLength = 0;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &maxLength);

        std::vector<char> errorLog(maxLength);
        glGetShaderInfoLog(shader, maxLength, &maxLength, &errorLog[0]);

        Logger::Append(Logger::LogLevel::LOGLEVEL_ERROR, "Shader compilation failed!");
        Logger::Append(Logger::LogLevel::LOGLEVEL_ERROR, &errorLog[0]);        

    }

    return shader;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function Bind()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shader::bind()
{
    glUseProgram(m_program);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function GetProgram()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Shader::getProgram()
{
    return m_program;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function GetAttribLocation()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Shader::getAttribLocation(std::string attribute)
{
    //get the position of the attribute specified in text
    int position = glGetAttribLocation(m_program, attribute.c_str());
    if (position < 0)
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Failed to get the storage location of attribute" + attribute);
        return -1;
    }
    return position;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function GetUniformLocation()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int Shader::getUniformLocation(std::string name)
{
    int location = glGetUniformLocation(m_program, name.c_str());
    if (location < 0)
    {
        Logger::Append(Logger::LogLevel::LOGLEVEL_INFO, "Failed to get the storage location of uniform: " + name);
        return -1;
    }
    return location;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function setUniformFloat()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shader::setUniformFloat(const std::string& name, float val1) {
    glUniform1f(getUniformLocation(name.c_str()), val1);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function setUniformFloat3()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shader::setUniformFloat3(const std::string& name, float val1, float val2, float val3) {
    glUniform3f(getUniformLocation(name.c_str()), val1, val2, val3);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function setUniformFloat4()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shader::setUniformFloat4(const std::string& name, glm::vec4& vec) {
    glUniform4fv(getUniformLocation(name.c_str()), 1, glm::value_ptr(vec));
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Function setUniformMat4()
//
//
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Shader::setUniformMat4(const std::string& name, glm::mat4& mat) {
    glUniformMatrix4fv(getUniformLocation(name.c_str()), 1, GL_FALSE, glm::value_ptr(mat));
}